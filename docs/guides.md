# Guides

## Strict and Act

The decorator API `act` marks out the methods which you want to use as action methods, and it will force the model to a strict mode. 

If a model is working in a strict mode, only the methods with decorator `act` can update state.

If you want to force a model to strict mode, you can use class decorator `strict`. It can check out if there are some `act` decorated action methods, and throw error when no `act` decorated method is detected.

```typescript
import {act, flow, Flows, strict,experience,create,Model} from "agent-reducer";

experience();

describe('test of strict',()=>{

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[] | null,
        list: User[],
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    test('When use `strict` mode, you have to mark out which `method` can generate a new state',async ()=>{
        @strict()
        class UserListModel implements Model<UserListState> {

            state: UserListState = {
                source: [],
                list: [],
                loading: false,
            };

            // in strict mode,
            // only the method with `act` decorator can generate new state
            @act()
            private load():UserListState {
                return {...this.state, loading: true};
            }

            private changeSource(source: User[]):UserListState {
                return {...this.state,source,list:source};
            }

            private unload():UserListState {
                return {...this.state, loading: false};
            }

            @flow(Flows.latest())
            async loadSource() {
                this.load();
                try {
                    const source: User[] = await new Promise((resolve) => {
                        resolve([...dataSource]);
                    });
                    this.changeSource(source);
                } finally {
                    this.unload();
                }
            }

        }

        const {agent,connect,disconnect} = create(UserListModel);
        connect();
        // only load method is act method,
        // so, only load method can generate new state
        await agent.loadSource();
        expect(agent.state.loading).toBe(true);
        disconnect();
    });

    test('The `act` decorator can lead model to strict automatically',async ()=>{
        // the `act` decorator can lead model to strict automatically
        class UserListModel implements Model<UserListState> {

            state: UserListState = {
                source: [],
                list: [],
                loading: false,
            };

            // in strict mode,
            // only the method with `act` decorator can generate new state
            @act()
            private load():UserListState {
                return {...this.state, loading: true};
            }

            private changeSource(source: User[]):UserListState {
                return {...this.state,source,list:source};
            }

            private unload():UserListState {
                return {...this.state, loading: false};
            }

            @flow(Flows.latest())
            async loadSource() {
                this.load();
                try {
                    const source: User[] = await new Promise((resolve) => {
                        resolve([...dataSource]);
                    });
                    this.changeSource(source);
                } finally {
                    this.unload();
                }
            }

        }

        const {agent,connect,disconnect} = create(UserListModel);
        connect();
        // only load method is act method,
        // so, only load method can generate new state
        await agent.loadSource();
        expect(agent.state.loading).toBe(true);
        disconnect();
    });

    test('In `strict` mode, if there is no `act` decorated method, it will lead to an error',()=>{
        @strict()
        class Counter {

            state = 0;

            increase(){
                return this.state+1;
            }
        }

        const {connect} = create(Counter);
        expect(()=>connect()).toThrow();
    })

})
```

## Effect

From `agent-reducer@4.2.0` we add some new APIs: [addEffect](/api?id=addeffect), [effect](/api?id=effect). These APIs are created for listening the state change of a model instance, and do some addition work for completing the whole mission.

```typescript
addEffect((prevState, state, methodName, action)=>{
    // `prevState` is the model state before this change.
    // `state` is the model state after this change.
    // `methodName` is the name of model or agent method
    // which leads this change.
    // action is generated by the state change method,
    // action:{type:string, prevState:State, state:State, params:any[]}
    // action.type === methodName, 
    // action.params is the params from the change act method.

    // If this effect is caused by effect mount,
    // param `methodName` is `null`.
    ......
    // return function destroy() {
    //   ......
    // }
    // if returns a function, 
    // this function will be called before effect callback triggered again. 
    // It is often used for clean or destroy something.
},model, method);
```

### Model effect

If you want to listen to all the state changes of model, you can add a effect `callback` and a model instance (or an agent) as params into API [addEffect](/api?id=addeffect) like: `addEffect(callback, model)`, the `callback` will be triggered as soon as there is no running mission for model instance, and then everytime when the state change of model happens, it can be triggered again, until the effect is unmounted manually or automatically by model destroying.

Listen to all the state changes of model (model effect):

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe('the basic usage about effect', () => {

    test('use model effect', () => {
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        // effect callback accepts params: prevState, state, methodName
        const effectCallback: EffectCallback<number> = jest.fn((prev,state) => {
            if (state < 0) {
                // time: 3
                // if the state is lt 0,
                // use `agent.reset` method to set state to 0,
                // reset makes state change happen,
                // so it triggers this effect callback too.
                agent.reset();
            }
        });
        // time: 1
        // add effect callback to listen the model state change,
        // the callback is called immediately,
        // and the current state is a initial state 0,
        // so, it will not call `agent.reset`.
        addEffect(effectCallback, model);

        // time: 2
        // decrease method make the state to be -1,
        // but the effect callback is triggered,
        // then the `agent.reset` method reset state to 0
        agent.decrease();
        expect(agent.state).toBe(0);

        // time: 4
        // increase method make the state to be 1,
        // and the effect callback is triggered,
        // but the current state can not make `agent.reset` start.
        agent.increase();
        expect(agent.state).toBe(1);
        // watch the time mark
        expect(effectCallback).toBeCalledTimes(4);
        disconnect();
    });

});
```

### Method effect

If you want to listen to state changes leaded by specific `method`, you can add `callback`, `model`, `method` as params into API `addEffect`, like: `addEffect(callback, model, method)`. Then only the state changes leaded by this specific `method` can trigger `effect callback`. When the param `method` is `*`, the effect listen to all the method state changes.

Listen on the state changes leaded by this specific `method` (method effect):

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe('the basic usage about effect', () => {

    test('use method effect', () => {
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        const effectCallback: EffectCallback<number> = jest.fn((prev,state) => {
            if (state < 0) {
                // if the state is lt 0,
                // use `agent.reset` method to set state to 0
                agent.reset();
            }
        });

        // add effect on the `decrease` method,
        // and filter the state changes from `decrease` method.
        // It only triggered by the method `decrease` state change.
        addEffect(effectCallback, model, model.decrease);

        // `decrease` state to -1 lead to `reset`
        agent.decrease();
        expect(agent.state).toBe(0);
        agent.increase();
        expect(agent.state).toBe(1);
        // the `increase` above can not trigger effect callback,
        // which only filter the state change from `decrease` method.
        expect(effectCallback).toBeCalledTimes(1);
        disconnect();
    });

});
```

Listen on a agent or a agent method:

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe('the basic usage about effect', () => {

    test('we can add effect onto a agent or method from agent too', () => {
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        const effectCallback: EffectCallback<number> = jest.fn();

        const decreaseEffectCallback: EffectCallback<number> = jest.fn((prev,state) => {
            if (state < 0) {
                agent.reset();
            }
        });

        // add effect onto a agent is same as add it onto the model
        addEffect(effectCallback, agent);

        // add effect onto a agent method is same as add it onto the model method
        addEffect(decreaseEffectCallback, agent, agent.decrease);

        agent.decrease();
        expect(agent.state).toBe(0);
        agent.increase();
        expect(agent.state).toBe(1);
        expect(effectCallback).toBeCalledTimes(4);
        expect(decreaseEffectCallback).toBeCalledTimes(1);
        disconnect();
    });

});
```

### Effect destroy

If the effect callback returns a `function`, this `function` is also called destroy function, and it is always called before its effect callback be triggered again. Also, it will be called when the effect is unmounted from model instance.

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe("use effect destroy callback",()=>{

    test('use destroy callback returned from effect callback',()=>{
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        const destroy = jest.fn();

        const effectCallback: EffectCallback<number> = jest.fn((prev,state)=>{
            if(state<0){
                agent.reset();
            }
            // if the effect callback returns a destroy callback,
            // the destroy callback will be invoked every time before effect callback
            // running again.
            // It will also be invoked when the disconnect method has destroyed all agent connections on model
            return destroy;
        });

        addEffect(effectCallback, model, model.decrease);

        // first time to trigger effect, so the destroy callback will not be invoked.
        agent.decrease();
        expect(agent.state).toBe(0);

        expect(effectCallback).toBeCalledTimes(1);
        expect(destroy).toBeCalledTimes(0);

        // trigger effect again, before the effect callback running,
        // the destroy callback is invoked.
        agent.decrease();
        expect(agent.state).toBe(0);

        expect(effectCallback).toBeCalledTimes(2);
        expect(destroy).toBeCalledTimes(1);

        // disconnect make destroy work last time.
        disconnect();
        expect(destroy).toBeCalledTimes(2);
    });

});
```

### Effect update and unmount

When all the model connections are destroyed, the effects on model or model methods are often unmounted automatically. But, if you want to unmount effect manually, you can try the `unmount` method from a `addEffect` API callback returns.

How to use unmount:

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe("use other abilities of effect",()=>{

    test('unmount effect manually',()=>{
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        const destroy = jest.fn();

        const effectCallback: EffectCallback<number> = jest.fn((prev,state)=>{
            if(state<0){
                agent.reset();
            }
            return destroy;
        });

        const {unmount} = addEffect(effectCallback, model,'decrease');

        agent.decrease();
        expect(agent.state).toBe(0);

        expect(effectCallback).toBeCalledTimes(1);
        // unmount here
        unmount();
        // when the effect is unmounted, the destroy callback runs.
        expect(destroy).toBeCalledTimes(1);

        // there is no effect for decrease method now,
        // so, the state is decreased to -1
        agent.decrease();
        expect(agent.state).toBe(-1);

        expect(effectCallback).toBeCalledTimes(1);
        // there is no effect for decrease method now,
        // so, the destroy callback will not be invoked.
        expect(destroy).toBeCalledTimes(1);

        disconnect();
        expect(destroy).toBeCalledTimes(1);
    });

});
```

Sometimes we need to update the effect callback manually, so, `update` method from `addEffect` API returns is a good choice.

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

class CountModel implements Model<number> {

    state = 0;

    increase() {
        return this.state + 1;
    }

    decrease() {
        return this.state - 1;
    }

    reset() {
        return 0;
    }

}

describe("use other abilities of effect",()=>{

    test('use update method for updating the effect callback',()=>{
        const model = new CountModel();
        const {agent, connect, disconnect} = create(model);
        connect();

        const effectCallback: EffectCallback<number> = jest.fn((prev,state)=>{
            if(state<0){
                agent.reset();
            }
        });

        const effect = addEffect(effectCallback, model, 'decrease');

        agent.decrease();
        expect(agent.state).toBe(0);

        // update effect callback to another callback
        effect.update(jest.fn());

        agent.decrease();
        // the new effect callback is a mock function,
        // it can not reset state.
        expect(agent.state).toBe(-1);

        expect(effectCallback).toBeCalledTimes(1);

        disconnect();
    });

});
```

## Flow

We have used to write a model class with some action methods for reducing next state, and write more complex work flow codes outside the model. For example, when we want to complete a page query work, we need to make it loading first, then deploy a model method to fetch data and change model state, finally, we should turn off the loading. So, we have to do things to change loading state outside the model, or write turn up and turn off loading code in different methods. it split one work flow to different parts. 

Now, we suppose you to try decorator `@flow`, and join these work flow parts
together inside a model method. We call these methods `flow methods`.

In a `flow method`, keyword `this` is an agent object created temporarily for a work flow. That means you can call normal `action methods` in these `flow methods` for state process and state change. 

The below codes shows how to use `@flow`.

```typescript
import {Flows, flow, create, effect, Model} from "agent-reducer";

describe('how to use flow', () => {

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[] | null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        private load() {
            return {...this.state, loading: true};
        }

        private unload() {
            return {...this.state, loading: false};
        }

        private filterList(source: User[], filterName: string) {
            const list = source!.filter(({name}) => name.startsWith(filterName));
            return {...this.state, source, filterName, list};
        }

        private changeSource(source: User[] | null) {
            const {filterName} = this.state;
            return this.filterList(source || [], filterName);
        }

        // use decorator flow to make a flow method
        @flow()
        async loadSource() {
            // flow method can call action method to change state,
            // and make `state.loading` to be `true`.
            this.load();
            try {
                // fetch users from remote service
                const source: User[] = await new Promise((resolve) => {
                    resolve([...dataSource]);
                });
                // flow method can call action method to change state,
                // and change source
                this.changeSource(source);
            } finally {
                // after all jobs, we need to set loading to 'false'
                this.unload();
            }
        }

    }

    test('try flow method, it can organize action methods together as a work flow', async () => {
        const {agent, connect, disconnect} = create(UserListModel);
        const changes: string[] = [];
        connect((action) => {
            changes.push(action.type);
        });
        // there are 3 action methods: load, changeSource, unload
        await agent.loadSource();
        expect(agent.state.source).toEqual(dataSource);
        expect(changes.length).toBe(3);
        disconnect();
    });

});
```

A flow method can use another one inside, and the inside one keeps its own `WorkFlow` mode.

```typescript
import {Flows, flow, create, effect, Model} from "agent-reducer";

describe('how to use flow', () => {

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[] | null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        private load() {
            return {...this.state, loading: true};
        }

        private changeFilterName(filterName: string) {
            return {...this.state, filterName};
        }

        private changeSource(source: User[] | null) {
            const {filterName} = this.state;
            return this.filterList(source || [], filterName);
        }

        private unload() {
            return {...this.state, loading: false};
        }

        private filterList(source: User[], filterName: string) {
            const list = source!.filter(({name}) => name.startsWith(filterName));
            return {...this.state, source, filterName, list};
        }

        // use `Flows` to set a debounce work flow
        @flow(Flows.debounce(200))
        private filterDebounce() {
            const {source, filterName} = this.state;
            this.filterList(source || [], filterName);
        }

        // use decorator flow to make a flow method,
        // set `Flows.latest()` to take the newest state changes of
        // this flow method.
        @flow(Flows.latest())
        async loadSource() {
            // flow method can call action method to change state,
            // and make `state.loading` to be `true`.
            this.load();
            try {
                // fetch users from remote service
                const source: User[] = await new Promise((resolve) => {
                    resolve([...dataSource]);
                });
                // flow method can call action method to change state,
                // and change source
                this.changeSource(source);
            } finally {
                // after all jobs, we need to set loading to 'false'
                this.unload();
            }
        }

        @flow()
        changeFilterNameThenFilter(filterName:string){
            this.changeFilterName(filterName);
            // the flow method called by others,
            // keeps its own `WorkFlow`.
            // So, it keeps `debounce` work flow mode.
            this.filterDebounce();
            // If you want to make inside flow method 
            // works as part of the current method,
            // and take the current method `WorkFlow` env,
            // you should keep the inside one with no `WorkFlow`,
            // like `@flow()`
        }

    }

    test('An flow method can call another one, and keeps their own `WorkFlows` on', async () => {
        const {agent, connect, disconnect} = create(UserListModel);
        const changes: string[] = [];
        connect(({state}) => {
            changes.push(state);
        });
        // there are 3 action methods: load, changeSource, unload
        await agent.loadSource();
        // there are 1 action methods: changeFilterName
        agent.changeFilterNameThenFilter('Lucy');
        // there are 2 action methods: changeFilterName, filterList
        agent.changeFilterNameThenFilter('Lily');
        await new Promise((resolve) => setTimeout(resolve,500));

        expect(changes.length).toBe(6);
        expect(agent.state.list).toEqual([{id: 4, name: 'Lily'}]);
        disconnect();
    });

});
```

There is a way to catch the error throw from `flows` or `effects`.

```typescript
import {Flows, flow, create, effect, middleWare, MiddleWarePresets, Model} from "agent-reducer";

type User = {
    id?:number,
    username:string,
    role?:'master'|'user'|'guest',
    password?:string
    name?:string,
    age?:number,
    sex?:'male'|'female'
};

class UserModel implements Model<User>{

    state:User = {
        username:'guest'
    };

    login(username:string,password:string):User{
        return {username,password};
    }

    loginSuccess(user:User):User{
        return user;
    }

    @middleWare(MiddleWarePresets.takePromiseResolve())
    modifyPassword(oldPassword:string){
        const {username} = this.state;
        return new Promise((resolve, reject)=>{
            if(username=='nike'&&oldPassword==='123'){
                resolve({id:1,username:'nike',name:'nick',age:18,sex:'male',role:'guest'});
            }else{
                reject('error username or password');
            }
        });
    }

    @flow()
    @effect(()=>UserModel.prototype.login)
    async loginEffect(prevState:User){
        const {username,password} = this.state;
        if(!password){
            throw new Error('password must not be empty');
        }
        return this.loginDirect(username,password);
    }

    @flow()
    async loginDirect(username:string,password:string){4
        const user:User = await new Promise((resolve, reject)=>{
            if(username=='nike'&&password==='123'){
                resolve({id:1,username:'nike',name:'nick',age:18,sex:'male',role:'guest'});
            }else{
                reject('error username or password');
            }
        });
        return this.loginSuccess(user);
    }

}

describe('flow.error',()=>{

    test('try error username, and catch error by use API `flow.error`',async ()=>{
        const {agent, connect, disconnect} = create(UserModel);
        connect();
        let exception:string='';
        flow.error(agent,(error,methodName)=>{
            exception = `error from method "${methodName}":${error}`;
        });
        agent.login('nik','123');
        await new Promise((resolve)=>setTimeout(resolve));

        expect(exception).toBe(`error from method "loginEffect":error username or password`);
        disconnect();
    });

    test('try unError',async ()=>{
        const {agent, connect, disconnect} = create(UserModel);
        connect();
        let exception:string='';
        const unsubscribe = flow.error(agent,(error,methodName)=>{
            exception = `error from method "${methodName}":${error}`;
        });
        agent.login('nike','123');
        await Promise.resolve();
        unsubscribe();
        try {
            await agent.modifyPassword('12');
        }catch (e) {
            expect(e).toBe('error username or password');
        }
        expect(exception).toBe('');
        disconnect();
    });
})

```

If you want to change the `workFlow` of a inside flow method temporary, please use `flow.force` API.

```typescript
import {Flows, flow, create, effect, middleWare, MiddleWarePresets, Model} from "agent-reducer";

describe('use `flow.force` API',()=>{

    type User = {
        id?: number,
        username: string,
        role?: 'master' | 'user' | 'guest',
        password?: string
        name?: string,
        age?: number,
        sex?: 'male' | 'female'
    };

    class UserModel implements Model<User> {

        state: User = {
            username: 'guest'
        };

        changeUserName(username: string) {
            return {...this.state, username};
        }

        updateUser(user: User): User {
            return user;
        }

        @flow(Flows.debounce(200))
        async fetchUser(username: string) {
            const user: User = await new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({
                        id: 1,
                        username: username,
                        name: username,
                        role: 'user',
                        age: 20
                    } as User);
                });
            });
            this.updateUser(user);
        }

        @effect(() => UserModel.prototype.changeUserName)
        effectOfKeyUsername() {
            // 'flow.force' can force the `WorkFlow` of as inside flow method.
            flow.force(this,Flows.default()).fetchUser(this.state.username);
        }

    }

    test('if you want to rewrite the `WorkFlow` of a inside flow method, you can use `flow.force`', async () => {
        const {agent, connect, disconnect} = create(UserModel);
        const nameChanges: string[] = [];
        connect(({state}) => {
            if (!state.name) {
                return;
            }
            nameChanges.push(state.name);
        });
        agent.changeUserName('a');
        agent.changeUserName('ab');
        await new Promise((resolve) => setTimeout(resolve));

        expect(nameChanges).toEqual(['a','ab']);
        disconnect();
    });

});
```

## avatar

Flow can do many thing to compose requests and state change methods together as a work flow. Sometimes, we even want to use the interface functions from platform, but, use these interfaces directly in model is not a good idea. That make model difficult to move to other platforms.

Now, we add a new API `avatar` to resolve this problem. `Avatar` use the `Algebraic Effects` mode to fix it. You can describe a simple `interfaces object` to replace the functions from platform, and implements these functions before using in the platform codes.

When the method of `avatar(interfaces).current` is used, it always finds the if the function is implemented, and use the implement one as possible as it can, if the function is not exist in the implement one, it use the relative function from `interfaces object` for a replace.

How to use a global avatar? 

```typescript
import {
    Flows, 
    flow, 
    create, 
    effect, 
    avatar,
    Model
} from "agent-reducer";

describe('how to use global avatar', () => {

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[] | null,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    const prompt = avatar({
        success:(info:string)=>undefined,
        error:(e:any)=>undefined
    });

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            loading: false,
        };

        private load() {
            return {...this.state, loading: true};
        }

        private changeSource(source: User[] | null) {
            return {...this.state, source};
        }

        private unload() {
            return {...this.state, loading: false};
        }

        @flow(Flows.latest())
        async loadSource() {
            this.load();
            try {
                const source: User[] = await new Promise((resolve) => {
                    resolve([...dataSource]);
                });
                this.changeSource(source);
                // use prompt.current.success to popup a message `fetch success`
                prompt.current.success('fetch success!');
            } catch (e) {
                // use prompt.current.error to popup a error message
                prompt.current.error(e);
            }finally {
                this.unload();
            }
        }

    }

    test('if you want to call outside effect function in model, you can use API `avatar`', async () => {
        const success = jest.fn().mockImplementation((info:string)=>console.log(info));
        // implement the interfaces of prompt avatar
        const destroy = prompt.implement({
            success,
        });
        const {agent, connect, disconnect} = create(UserListModel);
        connect();
        await agent.loadSource();
        expect(success).toBeCalledTimes(1);
        disconnect();
        // if you do not need this avatar,
        // please destroy it finally
        destroy();
    });

});
```

How to use avatar for different model instances.

```typescript
import {
    Flows, 
    flow, 
    create, 
    effect, 
    avatar,
    Model
} from "agent-reducer";

describe('how to use model avatar', () => {

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[] | null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        prompt = avatar({
            success:(info:string)=>undefined,
            error:(e:any)=>undefined
        });

        private load() {
            return {...this.state, loading: true};
        }

        private changeSource(source: User[] | null) {
            return {...this.state,source}
        }

        private unload() {
            return {...this.state, loading: false};
        }

        @flow(Flows.latest())
        async loadSource() {
            this.load();
            try {
                const source: User[] = await new Promise((resolve) => {
                    resolve([...dataSource]);
                });
                this.changeSource(source);
                // use prompt.current.success to popup a message `fetch success`
                this.prompt.current.success('fetch success!');
            } catch (e) {
                // use prompt.current.error to popup a error message
                this.prompt.current.error(e);
            }finally {
                this.unload();
            }
        }

    }

    test('If you want to use `avatar` in model, please build avatar inside model', async () => {
        const success = jest.fn().mockImplementation((info:string)=>console.log(info));

        const {agent, connect, disconnect} = create(UserListModel);
        const {agent:another, connect:anotherConnect, disconnect:anotherDisconnect} = create(UserListModel);
        // implement avatar for different models
        const destroy = agent.prompt.implement({
            success,
        });
        connect();
        anotherConnect();
        await agent.loadSource();
        await another.loadSource();
        // the agent.prompt is implemented with avatar,
        // the another one is not.
        expect(success).toBeCalledTimes(1);
        disconnect();
        anotherDisconnect();
        // if you do not need this avatar,
        // please destroy it finally
        destroy();
    });

});
```

## Effect method

If you want to add effect inside model, and start it after this model is connected, you can use api [effect](/api?id=effect) to decorate a model method to be a effect callback. If you pass `*` into [effect](/api?id=effect) decorator, it will take all the methods of current model instance as the listening target. If you pass a callback which returns a method of current model into [effect](/api?id=effect) decorator as a param, it will only listen to the state changes leaded by this specific `method`.

The method decorated by [effect](/api?id=effect) is bind on an `agent` which is created temporary from current `model instance`. So, if deploy the method from keyword `this` in a effect callback, it will change the model state. The `effect` API will not lead a first running like: `addEffect(callback, model)` when use it. In fact, the effect method here is just a special flow method.

The code below is an example about how to use effect to control a user list model, we can fetch users and filter them with the property `name`.

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

describe("use decorator effect",()=>{

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[]|null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        fetchSource() {
            return {...this.state, loading: true};
        }

        changeSource(source: User[]|null) {
            return {...this.state, source, list: source};
        }

        finishLoading(){
            return {...this.state,loading: false};
        }

        // listen state changes from all methods,
        // all the effect method can not be called directly from `agent`,
        // so, make it a `private` method is a good idea.
        @effect('*')
        private async loadingEffect(prevSate: UserListState) {
            const {loading} = this.state;
            if (prevSate.loading === loading ||!loading) {
                return;
            }
            try {
                const source:User[] = await new Promise((resolve)=>{
                    resolve([...dataSource]);
                });
                // fetch source
                this.changeSource(source);
            }finally {
                // after all jobs, we need to set loading to 'false'
                this.finishLoading();
            }

        }

    }

    test('try effect listen to all methods ', async () => {
        const {agent, connect, disconnect} = create(UserListModel);
        connect();
        agent.fetchSource();
        expect(agent.state.loading).toBe(true);
        await new Promise((r)=>setTimeout(r));
        // the `loadingEffect` finally set loading to 'false'
        expect(agent.state.loading).toBe(false);
        disconnect();
    });

});
```

The code above shows how to use effect `fetch data`. The effect listen to the state change about `state.loading`, so, we calls `fetchSource` method to change `state.loading` to `true`, that makes `loadingEffect` works, and after the data fetching, the `effect method` call `this.changeSource` to change `state.source` and `state.list` (keyword `this` in effect is an agent object created by `agent-reducer` system).

If we want to listen the effect about state changes from special methods, we can try below.

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

describe("use decorator effect",()=>{

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[]|null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        fetchSource() {
            return {...this.state, loading: true};
        }

        changeFilterName(filterName: string) {
            return {...this.state, filterName};
        }

        changeSource(source: User[]|null) {
            return {...this.state, source, list: source};
        }

        finishLoading(){
            return {...this.state,loading: false};
        }

        private filter() {
            const {filterName, source} = this.state;
            const list = source!.filter(({name}) => name.startsWith(filterName));
            return {...this.state, list};
        }

        // listen state changes from special methods.
        @effect(()=>UserListModel.prototype.changeSource)
        @effect(() => UserListModel.prototype.changeFilterName)
        filterEffect() {
            // if the `filterName` or `source` in state changes,
            // invoke filter to change state.
            // In effect, we can call state change methods to change state.
            // And `this` now is an agent object.
            this.filter();
        }

        // listen state changes from all methods,
        // all the effect method can not be called directly from `agent`,
        // so, make it a `private` method is a good idea.
        @effect('*')
        private async loadingEffect(prevSate: UserListState) {
            const {loading} = this.state;
            if (prevSate.loading === loading ||!loading) {
                return;
            }
            try {
                const source:User[] = await new Promise((resolve)=>{
                    resolve([...dataSource]);
                });
                // fetch source
                this.changeSource(source);
            }finally {
                // after all jobs, we need to set loading to 'false'
                this.finishLoading();
            }

        }

    }

    test('try effect listen to a special method', async () => {
        const {agent, connect, disconnect} = create(UserListModel);
        connect();
        agent.fetchSource();
        expect(agent.state.loading).toBe(true);
        await new Promise((r)=>setTimeout(r));
        expect(agent.state.loading).toBe(false);
        agent.changeFilterName('L');
        // the `filterEffect` filter list by `filter` method
        expect(agent.state.list).toEqual([
            {id: 3, name: 'Lucy'},
            {id: 4, name: 'Lily'},
        ]);
        disconnect();
    });

});
```

We add a `filter name` function for our model by using effect to listen to the special methods: `changeSource` and `changeFilterName`, and no matter which method above changes state, the `filterEffect` will respose, it calls `filter` method to filter out list we want to show. 

Note: the effect method can not be called as a agent action method.

```typescript
import {
    EffectCallback, 
    Model, 
    addEffect, 
    create, 
    effect
} from "agent-reducer";

describe("use decorator effect",()=>{

    type User = {
        id: number,
        name: string
    };

    type UserListState = {
        source: User[]|null,
        list: User[],
        filterName: string,
        loading: boolean,
    }

    const dataSource: User[] = [
        {id: 1, name: 'Jimmy'},
        {id: 2, name: 'Jacky'},
        {id: 3, name: 'Lucy'},
        {id: 4, name: 'Lily'},
        {id: 5, name: 'Nike'},
    ];

    class UserListModel implements Model<UserListState> {

        state: UserListState = {
            source: [],
            list: [],
            filterName: '',
            loading: false,
        };

        fetchSource() {
            return {...this.state, loading: true};
        }

        changeFilterName(filterName: string) {
            return {...this.state, filterName};
        }

        changeSource(source: User[]|null) {
            return {...this.state, source, list: source};
        }

        finishLoading(){
            return {...this.state,loading: false};
        }

        private filter() {
            const {filterName, source} = this.state;
            const list = source!.filter(({name}) => name.startsWith(filterName));
            return {...this.state, list};
        }

        // listen state changes from special methods.
        @effect(()=>UserListModel.prototype.changeSource)
        @effect(() => UserListModel.prototype.changeFilterName)
        filterEffect() {
            // if the `filterName` or `source` in state changes,
            // invoke filter to change state.
            // In effect, we can call state change methods to change state.
            // And `this` now is an agent object.
            this.filter();
        }

        // listen state changes from all methods,
        // all the effect method can not be called directly from `agent`,
        // so, make it a `private` method is a good idea.
        @effect('*')
        private async loadingEffect(prevSate: UserListState) {
            const {loading} = this.state;
            if (prevSate.loading === loading ||!loading) {
                return;
            }
            try {
                const source:User[] = await new Promise((resolve)=>{
                    resolve([...dataSource]);
                });
                // fetch source
                this.changeSource(source);
            }finally {
                // after all jobs, we need to set loading to 'false'
                this.finishLoading();
            }

        }

    }

    test('the method effect can not besused from `agent` directly',()=>{
        const {agent, connect, disconnect} = create(UserListModel);
        connect();
        // the method effect can not be used from `agent` directly
        expect(()=>agent.filterEffect).toThrow();
        disconnect();
    });

});
```

## Work Flow

If you want to define a `WorkFlow` yourself, and use it into `@flow`, follow down.

```typescript
export type LaunchHandler = {
    shouldLaunch?:()=>boolean,
    shouldUpdate?:()=>boolean,
    didLaunch?:(result:any)=>any,
    invoke?:(method:(...args:any[])=>any)=>((...args:any[])=>any);
}

export type FlowRuntime = {
    state:Record<string, any>,
    resolve:(result:any)=>any;
    reject:(error:any)=>any
};

export type WorkFlow = (runtime:FlowRuntime)=>LaunchHandler;
```

example：

```typescript
export function myFlow(runtime:FlowRuntime){
    // before a flow method is started,
    // you can get runtime.state.
    // runtime.state is a method cache for your flow
    const state = runtime.state;
    return {
        shouldLaunch(){
            // before method,
            // you can return true/false to go on/stop method
            return true;
        },
        shouldUpdate(){
            // before call the action method in flow method，
            // return true/false to active/inactive a state change
            return true;
        },
        didLaunch(result:any){
            // after method running, 
            // you can get the running result.
        },
        invoke(method){
            // rewrite current method
            return function wrapMethod(...args:any[]){
                return method(...args);
            }
        },
    }
}
```


As we recommended yet, you can abandon MiddleWare, and go [next](/feature?id=feature) page to learn some useful features in `agent-reducer`. If you still need to learn MiddleWare, follow down.

## MiddleWare

MiddleWare is designed for reproducing state before state change happens. It is a function returns a connector function to the next one. So, the MiddleWares can be used individually, or be chained together. A MiddleWares chain is still a MiddleWare, and you can use API [applyMiddleWares](/api?id=applymiddlewares) to make it happen.

A MiddleWare structure should look like:

```typescript
// A `MiddleWare` is a function,
// it is called before method running with a `Runtime` param.
// `Runtime` is an helpful object,
// it contains a lot infos,
// like `Agent`\`Model`\`method name`\`method cache data`...
function middleWareLike(runtime: Runtime):NextProcess|void {

    // Function `nextProcess` is used for connecting the `stateProcess` function from next `MiddleWare`.
    // It is called after method finished immediately,
    // if you returns a void value like `undefined` instead of `nextProcess`,
    // you can skip the method running. 
    return function nextProcess(next: StateProcess): StateProcess {

        // Function `stateProcess` is used for reproducing state,
        // and you can call the `next` to pass the reproduced state to next `stateProcess` function ant time.
        return function stateProcess(state: any) {
            // `next` function is the `stateProcess` function from next `MiddleWare`.
            // If you don't want state change happens,
            // do not call the `next`, just return the state.
            return next(doSomething(state));
        };
    };
}
```

The structure of `Runtime`:

```typescript
export type Runtime<T extends Record<string, any>=any> = {
    // the calling method name
    methodName: string|number;
    // the params passed into method
    args?: any[];
    // the `Agent` object that calling method belong to
    agent: T;
    // the `Model` instance that calling method belong to
    model: T;
    // an running env object which only contains a `expired` property,
    // this property is used for disabling the state change of an `Agent` copy version  
    env: Env;
    // a cache data for MiddleWare,
    // you can store any thing inside this object
    cache: { [key: string]: any };
    // this is a Proxy handler callback,
    // you can create an Proxy object of `Model`,
    // and `Agent` will rebind the running method to the Proxy object.
    mapModel:(handler:ProxyHandler<T>)=>T;
};
```

## Chain MiddleWares

Every MiddleWare has a particular ability, if you want to compose some MiddleWares together, you can use api `applyMiddleWares`, this api can chain particular MiddleWares to be one, which contains the abilities of all you want to take from.

There is a rule about how to chain MiddleWares, that the prev one provides state for next one. A next MiddleWare should process the state more closer to the final state than the prev one.

We can learn how to chain them from the official api [MiddleWarePresets](/api?id=middlewarepresets). This api provides some useful MiddleWare chains, and we can use these chains directly. But before use them, we should know they are not the origin atom MiddleWare, the official atom MiddleWare set is stored in api [MiddleWares](/api?id=middlewares), and the MiddleWares in api `MiddleWarePresets` are the chaining from the atom MiddleWares.

Let's take a look at `MiddleWarePresets.takePromiseResolveAssignable()`.

```typescript
static takePromiseResolveAssignable():MiddleWare {
    return applyMiddleWares(
      // atom MiddleWare takePromiseResolve,
      // it pass a no promise data to next,
      // if the data is a promise,
      // it wait for the promise resolving,
      // then pass the resolve data to next.
      MiddleWares.takePromiseResolve(),
      // atom MiddleWare takeAssignable,
      // it merges the passed state with Model state shallowlly,
      // and pass the merged data to next. 
      MiddleWares.takeAssignable(),
    );
  }
```

This MiddleWare is chained by [MiddleWares.takePromiseResolve()](/api?id=takepromiseresolve) and [MiddleWares.takeAssignable()](/api?id=takeassignable). The first MiddleWare take the promise resolve data and pass it into the second one, then the second can use this data merge with `Model state`, and generate a final new state for `Model`.

## MiddleWare override

We have introduced how to add MiddleWare onto a method in [introduction page](/introduction?id=middleware). In this section, we will make a supplement about how to override the current MiddleWare on an `agent method`.

The MiddleWare can be override by its using priority. We will introduce the priority of MiddleWare override from low to high.

Let's take a look at the test about a `User` model:

``` typescript
import {
    create, 
    middleWare, 
    MiddleWarePresets,
    Model, 
    withMiddleWare,
} from "agent-reducer";

describe('MiddleWare override priority', () => {

    type User = {
        id: undefined | number
        name: string,
        nick: string
    }

    // this is a user model,
    // we can fetch user from server.
    // use class decorator to add MiddleWare,
    // can make this MiddleWare effect on all methods in this class
    @middleWare(MiddleWarePresets.takePromiseResolve())
    class UserModel implements Model<User> {

        state: User = {
            id: undefined,
            name: 'guest',
            nick: 'guest'
        };

        fetchCurrentUser() {
            return Promise.resolve({
                id: 0,
                name: 'name',
                nick: 'nick'
            });
        }

        updateCurrentUserName(name:string){
            return {name,nick:name};
        }

        @middleWare(MiddleWarePresets.takeNothing())
        updateCurrentUserNick(nick:string){
            return {nick};
        }

    }

    test('The lowest priority by using class decorator', async () => {
        const {agent,connect,disconnect} = create(UserModel);
        connect();
        // the MiddleWare from class decorator effect on the promise returning.
        await agent.fetchCurrentUser();
        expect(agent.state).toEqual({
            id: 0,
            name: 'name',
            nick: 'nick'
        });
        // the MiddleWare from class decorator can not effect the object which is not a promise,
        // this returning object is a part of state User type,
        // so the next state will be incomplete.
        // We need `MiddleWarePresets.takeAssignable` to merge it with this.state
        agent.updateCurrentUserName('name1');
        expect(agent.state).not.toHaveProperty('id');
        disconnect();
    });

    test('The MiddleWare added by api `create` can override the one added by using class decorator',async ()=>{
        const {agent,connect,disconnect} = create(UserModel,MiddleWarePresets.takePromiseResolveAssignable());
        connect();
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // and the MiddleWarePresets.takePromiseResolveAssignable() effect on the promise returning.
        // MiddleWarePresets.takePromiseResolveAssignable() is chained by
        // MiddleWares.takePromiseResolve() and MiddleWares.takeAssignable(),
        // so it can resolve the promise returning.
        await agent.fetchCurrentUser();
        expect(agent.state).toEqual({
            id: 0,
            name: 'name',
            nick: 'nick'
        });
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // this returning object is a part of state User type,
        // MiddleWarePresets.takePromiseResolveAssignable() can effect on it,
        // and merge it with this.state.
        agent.updateCurrentUserName('name1');
        expect(agent.state).toHaveProperty('id');
        disconnect();
    });

    test('The MiddleWare added by method decorator can override the two ways above',async ()=>{
        const {agent,connect,disconnect} = create(UserModel,MiddleWarePresets.takePromiseResolveAssignable());
        connect();
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // and the MiddleWarePresets.takePromiseResolveAssignable() effect on the promise returning.
        // MiddleWarePresets.takePromiseResolveAssignable() is chained by
        // MiddleWares.takePromiseResolve() and MiddleWares.takeAssignable(),
        // so it can resolve the promise returning.
        await agent.fetchCurrentUser();
        expect(agent.state).toEqual({
            id: 0,
            name: 'name',
            nick: 'nick'
        });
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // this returning object is a part of state User type,
        // MiddleWarePresets.takePromiseResolveAssignable() can effect on it,
        // and merge it with this.state.
        agent.updateCurrentUserName('name1');
        expect(agent.state).toHaveProperty('id');
        // The MiddleWare added by method decorator override the other MiddleWares,
        // but it only effect on the method.
        agent.updateCurrentUserNick('nick1');
        // `MiddleWarePresets.takeNothing()` abandons all the state changes,
        // so state.nick is not change.
        expect(agent.state.nick).not.toBe('nick1');
        disconnect();
    });

    test('API `withMiddleWare` has a highest priority',async ()=>{
        const {agent,connect,disconnect} = create(UserModel,MiddleWarePresets.takePromiseResolveAssignable());
        connect();
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // and the MiddleWarePresets.takePromiseResolveAssignable() effect on the promise returning.
        // MiddleWarePresets.takePromiseResolveAssignable() is chained by
        // MiddleWares.takePromiseResolve() and MiddleWares.takeAssignable(),
        // so it can resolve the promise returning.
        await agent.fetchCurrentUser();
        expect(agent.state).toEqual({
            id: 0,
            name: 'name',
            nick: 'nick'
        });
        // The MiddleWare from class decorator is override by the MiddleWare from api `create`,
        // this returning object is a part of state User type,
        // MiddleWarePresets.takePromiseResolveAssignable() can effect on it,
        // and merge it with this.state.
        agent.updateCurrentUserName('name1');
        expect(agent.state).toHaveProperty('id');

        const {updateCurrentUserNick} = withMiddleWare(agent,MiddleWarePresets.takeAssignable());
        // The MiddleWare added by method decorator is override by the one added from `withMiddleWare`,
        // `withMiddleWare` copy a new agent for override.
        updateCurrentUserNick('nick1');
        // `MiddleWarePresets.takeNothing()` is override by `MiddleWarePresets.takeAssignable()` temporarily
        expect(agent.state.nick).toBe('nick1');
        disconnect();
    });

});
```

check unit test [guides.test.ts](https://github.com/filefoxper/agent-reducer/blob/master/test/en/guides.test.ts).

From the example above, we can know that the MiddleWare priority is:

```
class decorator < create api < method decorator < withMiddleWare api
```

As we know the API [withMiddleWare](/api?id=withmiddleware) can use a highest priority MiddleWare on a `Agent` copy object. Why we have to base this `MiddleWare` on a `Agent` copy object? The primary reason is we do not want to make effect to the origin `Agent` usage, the secondary is about `Lifecycle MiddleWare`. In next section, we will introduce what is a `Lifecycle MiddleWare`.

## Lifecycle MiddleWare

Lifecycle MiddleWare is a special kind of MiddleWare which can control the state change ability of `Agent`. When an `Agent` is disabled by it, the `Agent` can not change state anyway. 

The official Lifecycle MiddleWare is [LifecycleMiddleWares.takeLatest()](/api?id=takelatest). When it makes a state change finish, it disables the current `Agent`, and rebuild one to replace the old one, so the old one can not change state again, the next state change only can be happened in the new `Agent`. In simple terms, every `Agent` can change state once, and the state change happens with an order, one by one. This Lifecycle MiddleWare is often used with `takePromiseResolve()`, and we have chained to be a new MiddleWare `MiddleWarePresets.takeLatest()` for normal usage.

Here is a example about fetch to-do list by page change. And we can know what `MiddleWarePresets.takeLatest()` can do after read it.

```typescript
import {
    create, 
    middleWare, 
    MiddleWarePresets,
    Model, 
    withMiddleWare,
} from "agent-reducer";

describe('Lifecycle MiddleWare',()=>{

    type Todo = {
        content: string,
        status: 'new' | 'doing' | 'done'
    };

    const todoList1: Array<Todo> = [
        {content: 'create project structure', status: 'done'},
        {content: 'coding', status: 'done'},
    ];

    const todoList2:Array<Todo> = [
        {content: 'unit test', status: 'doing'},
        {content: 'write docs', status: 'new'},
    ];

    // This is a to-do list model,
    // we can fetch list from server by page.
    // We want the page data fetched by the order of method `fetch` trigger.
    @middleWare(MiddleWarePresets.takePromiseResolve())
    class TodoList implements Model<Array<Todo>> {

        state = [];

        fetch(page:number): (Promise<Array<Todo>>) {
            // simulate a delay when page is 1
            if(page === 1){
                return new Promise((resolve) => {
                    setTimeout(()=>{
                        resolve([...todoList1]);
                    });
                });
            }
            return new Promise((resolve) => {
                resolve([...todoList2]);
            });
        }

    }

    test('without `MiddleWarePresets.takeLatest()`, page 1 may override the newest page 2',async ()=>{
        const {agent,connect,disconnect} = create(TodoList);
        connect();
        // We fetch page 1 data first, then fetch the page 2.
        const fetchLoader1 = agent.fetch(1);
        const fetchLoader2 = agent.fetch(2);
        await Promise.all([fetchLoader1,fetchLoader2]);
        // The data of page 1 is delayed,
        // it overrides the newest data of page 2.
        // The data of page 1 is not the result we want to see.
        expect(agent.state).toEqual(todoList1);
        disconnect();
    });

    test('`MiddleWarePresets.takeLatest()` can make state change by order',async ()=>{
        const {agent,connect,disconnect} = create(TodoList);
        connect();
        // We copy an agent for lifecycle MiddleWare `takeLatest`
        const agentCopy = withMiddleWare(agent,MiddleWarePresets.takeLatest());
        // We fetch page 1 data first, then fetch the page 2.
        // Be careful, if we want `MiddleWarePresets.takeLatest()` be effective,
        // we need to call the fetch method from the copy `Agent`.
        const fetchLoader1 = agentCopy.fetch(1);
        const fetchLoader2 = agentCopy.fetch(2);
        await Promise.all([fetchLoader1,fetchLoader2]);
        // The data of page 1 is delayed,
        // so `MiddleWarePresets.takeLatest()` accept the data from page 2 first,
        // then `MiddleWarePresets.takeLatest()` kills the old `Agent`,
        // which is waiting for the data of page 1.
        // The newest data of page 2 keeps.
        expect(agent.state).toEqual(todoList2);
        disconnect();
    });

    test('The decorator API `middleWare` always returns method from an `Agent` copy object',async ()=>{

        @middleWare(MiddleWarePresets.takePromiseResolve())
        class TodoList implements Model<Array<Todo>> {

            state = [];

            // we can add `takeLatest` like this too
            @middleWare(MiddleWarePresets.takeLatest())
            fetch(page:number): (Promise<Array<Todo>>) {
                // simulate a delay when page is 1
                if(page === 1){
                    return new Promise((resolve) => {
                        setTimeout(()=>{
                            resolve([...todoList1]);
                        });
                    });
                }
                return new Promise((resolve) => {
                    resolve([...todoList2]);
                });
            }

        }

        const {agent,connect,disconnect} = create(TodoList);
        connect();
        // We fetch page 1 data first, then fetch the page 2.
        const fetchLoader1 = agent.fetch(1);
        const fetchLoader2 = agent.fetch(2);
        await Promise.all([fetchLoader1,fetchLoader2]);
        // so `MiddleWarePresets.takeLatest()` accept the data from page 2 first,
        // then `MiddleWarePresets.takeLatest()` kills the old `Agent`,
        // which is waiting for the data of page 1.
        // The newest data of page 2 keeps.
        expect(agent.state).toEqual(todoList2);
        disconnect();
    });
    
    test('The `create` API can not accept a Lifecycle MiddleWare currently',()=>{
        expect(()=>{
            create(TodoList,MiddleWarePresets.takeLatest());
        }).toThrow('Can not use a lifecycle `MiddleWare` for creating, please use this `MiddleWare` with api `withMiddleWare` or `middleWare`.');
    });

});
```

check unit test [guides.test.ts](https://github.com/filefoxper/agent-reducer/blob/master/test/en/guides.test.ts).

So we have know what a Lifecycle MiddleWare can do, but how it can work like this, and how we can write a customized Lifecycle MiddleWare?

The structure of Lifecycle MiddleWare is almost the same as a normal MiddleWare. The only different is the MiddleWare param `Runtime`. Lifecycle MiddleWare has a rebuild able `Runtime` param.

```typescript
export interface LifecycleEnv extends Env {
  expire: () => void;
  rebuild: () => void;
}

export interface LifecycleRuntime<T = any> extends Runtime<T> {
  env: LifecycleEnv;
}

export type LifecycleMiddleWare = (<T>(
  runtime: LifecycleRuntime<T>
) => NextProcess | void)
```

We can use `LifecycleRuntime.env.expire` to disable the current `Agent`, or use `LifecycleRuntime.env.rebuild` to disable the current `Agent`, and create a new one to replace it.

If we want to use the Lifecycle feature to our customized MiddleWare, we should use API [toLifecycleMiddleWare](/api?id=tolifecyclemiddleware) to mark it, then `agent-reducer` system can recognize it as a real Lifecycle MiddleWare.

In `agent-reducer`, there are some useful official MiddleWares, if you are interest in them, please read how to use them in API `MiddleWarePresets`.

